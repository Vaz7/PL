Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> converter
Rule 1     converter -> file
Rule 2     file -> file_lines last_line
Rule 3     file_lines -> line
Rule 4     file_lines -> file_lines line
Rule 5     line -> NEWLINE
Rule 6     line -> elem_newline
Rule 7     last_line -> elem
Rule 8     last_line -> empty
Rule 9     elem_newline -> atrib NEWLINE
Rule 10    elem_newline -> table NEWLINE
Rule 11    elem_newline -> array_table NEWLINE
Rule 12    empty -> <empty>
Rule 13    elem -> atrib
Rule 14    elem -> table
Rule 15    elem -> array_table
Rule 16    atrib -> FLOAT EQUALS content
Rule 17    atrib -> key EQUALS content
Rule 18    atrib -> key EQUALS content COMMENT
Rule 19    atrib -> key DOT atrib
Rule 20    content -> value
Rule 21    content -> APAR arr_cont
Rule 22    content -> APAR NEWLINE arr_cont
Rule 23    content -> ACHAV table_cont
Rule 24    arr_cont -> CPAR
Rule 25    arr_cont -> a_cont CPAR
Rule 26    arr_cont -> a_cont COMMA CPAR
Rule 27    arr_cont -> a_cont NEWLINE CPAR
Rule 28    arr_cont -> a_cont COMMA NEWLINE CPAR
Rule 29    a_cont -> COMMENT NEWLINE a_cont
Rule 30    a_cont -> COMMENT NEWLINE
Rule 31    a_cont -> a_cont COMMA NEWLINE
Rule 32    a_cont -> content
Rule 33    a_cont -> a_cont COMMA a_cont
Rule 34    a_cont -> a_cont COMMA NEWLINE a_cont
Rule 35    table_cont -> CCHAV
Rule 36    table_cont -> t_cont CCHAV
Rule 37    t_cont -> key EQUALS content
Rule 38    t_cont -> t_cont COMMA key EQUALS content
Rule 39    key -> KEY
Rule 40    key -> INTEGER
Rule 41    key -> STRING
Rule 42    key -> STRING_LITERAL
Rule 43    value -> STRING
Rule 44    value -> BOOL
Rule 45    value -> NULL
Rule 46    value -> INTEGER
Rule 47    value -> FLOAT
Rule 48    value -> BINARY
Rule 49    value -> OCTAL
Rule 50    value -> HEXA
Rule 51    value -> NAN
Rule 52    value -> INFINITY
Rule 53    value -> DATE
Rule 54    value -> TIME
Rule 55    value -> DATETIME
Rule 56    value -> MULTILINE_STRING
Rule 57    value -> STRING_LITERAL
Rule 58    value -> MULTILINE_STRING_LITERAL
Rule 59    table -> table NEWLINE COMMENT
Rule 60    table -> table NEWLINE atrib
Rule 61    table -> APAR tab_cont CPAR
Rule 62    table -> APAR tab_cont CPAR COMMENT
Rule 63    tab_cont -> FLOAT
Rule 64    tab_cont -> tab_cont DOT tab_cont
Rule 65    tab_cont -> key
Rule 66    array_table -> array_table NEWLINE COMMENT
Rule 67    array_table -> array_table NEWLINE atrib
Rule 68    array_table -> APAR2 arr_table_cont CPAR2
Rule 69    array_table -> APAR2 arr_table_cont CPAR2 COMMENT
Rule 70    arr_table_cont -> arr_table_cont DOT arr_table_cont
Rule 71    arr_table_cont -> key

Terminals, with rules where they appear

ACHAV                : 23
APAR                 : 21 22 61 62
APAR2                : 68 69
BINARY               : 48
BOOL                 : 44
CCHAV                : 35 36
COMMA                : 26 28 31 33 34 38
COMMENT              : 18 29 30 59 62 66 69
CPAR                 : 24 25 26 27 28 61 62
CPAR2                : 68 69
DATE                 : 53
DATETIME             : 55
DOT                  : 19 64 70
EQUALS               : 16 17 18 37 38
FLOAT                : 16 47 63
HEXA                 : 50
INFINITY             : 52
INTEGER              : 40 46
KEY                  : 39
MULTILINE_STRING     : 56
MULTILINE_STRING_LITERAL : 58
NAN                  : 51
NEWLINE              : 5 9 10 11 22 27 28 29 30 31 34 59 60 66 67
NULL                 : 45
OCTAL                : 49
STRING               : 41 43
STRING_LITERAL       : 42 57
TIME                 : 54
error                : 

Nonterminals, with rules where they appear

a_cont               : 25 26 27 28 29 31 33 33 34 34
arr_cont             : 21 22
arr_table_cont       : 68 69 70 70
array_table          : 11 15 66 67
atrib                : 9 13 19 60 67
content              : 16 17 18 32 37 38
converter            : 0
elem                 : 7
elem_newline         : 6
empty                : 8
file                 : 1
file_lines           : 2 4
key                  : 17 18 19 37 38 65 71
last_line            : 2
line                 : 3 4
t_cont               : 36 38
tab_cont             : 61 62 64 64
table                : 10 14 59 60
table_cont           : 23
value                : 20

Parsing method: LALR

state 0

    (0) S' -> . converter
    (1) converter -> . file
    (2) file -> . file_lines last_line
    (3) file_lines -> . line
    (4) file_lines -> . file_lines line
    (5) line -> . NEWLINE
    (6) line -> . elem_newline
    (9) elem_newline -> . atrib NEWLINE
    (10) elem_newline -> . table NEWLINE
    (11) elem_newline -> . array_table NEWLINE
    (16) atrib -> . FLOAT EQUALS content
    (17) atrib -> . key EQUALS content
    (18) atrib -> . key EQUALS content COMMENT
    (19) atrib -> . key DOT atrib
    (59) table -> . table NEWLINE COMMENT
    (60) table -> . table NEWLINE atrib
    (61) table -> . APAR tab_cont CPAR
    (62) table -> . APAR tab_cont CPAR COMMENT
    (66) array_table -> . array_table NEWLINE COMMENT
    (67) array_table -> . array_table NEWLINE atrib
    (68) array_table -> . APAR2 arr_table_cont CPAR2
    (69) array_table -> . APAR2 arr_table_cont CPAR2 COMMENT
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    NEWLINE         shift and go to state 5
    FLOAT           shift and go to state 10
    APAR            shift and go to state 12
    APAR2           shift and go to state 13
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    converter                      shift and go to state 1
    file                           shift and go to state 2
    file_lines                     shift and go to state 3
    line                           shift and go to state 4
    elem_newline                   shift and go to state 6
    atrib                          shift and go to state 7
    table                          shift and go to state 8
    array_table                    shift and go to state 9
    key                            shift and go to state 11

state 1

    (0) S' -> converter .



state 2

    (1) converter -> file .

    $end            reduce using rule 1 (converter -> file .)


state 3

    (2) file -> file_lines . last_line
    (4) file_lines -> file_lines . line
    (7) last_line -> . elem
    (8) last_line -> . empty
    (5) line -> . NEWLINE
    (6) line -> . elem_newline
    (13) elem -> . atrib
    (14) elem -> . table
    (15) elem -> . array_table
    (12) empty -> .
    (9) elem_newline -> . atrib NEWLINE
    (10) elem_newline -> . table NEWLINE
    (11) elem_newline -> . array_table NEWLINE
    (16) atrib -> . FLOAT EQUALS content
    (17) atrib -> . key EQUALS content
    (18) atrib -> . key EQUALS content COMMENT
    (19) atrib -> . key DOT atrib
    (59) table -> . table NEWLINE COMMENT
    (60) table -> . table NEWLINE atrib
    (61) table -> . APAR tab_cont CPAR
    (62) table -> . APAR tab_cont CPAR COMMENT
    (66) array_table -> . array_table NEWLINE COMMENT
    (67) array_table -> . array_table NEWLINE atrib
    (68) array_table -> . APAR2 arr_table_cont CPAR2
    (69) array_table -> . APAR2 arr_table_cont CPAR2 COMMENT
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    NEWLINE         shift and go to state 5
    $end            reduce using rule 12 (empty -> .)
    FLOAT           shift and go to state 10
    APAR            shift and go to state 12
    APAR2           shift and go to state 13
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    last_line                      shift and go to state 18
    line                           shift and go to state 19
    elem                           shift and go to state 20
    empty                          shift and go to state 21
    elem_newline                   shift and go to state 6
    atrib                          shift and go to state 22
    table                          shift and go to state 23
    array_table                    shift and go to state 24
    key                            shift and go to state 11

state 4

    (3) file_lines -> line .

    NEWLINE         reduce using rule 3 (file_lines -> line .)
    FLOAT           reduce using rule 3 (file_lines -> line .)
    APAR            reduce using rule 3 (file_lines -> line .)
    APAR2           reduce using rule 3 (file_lines -> line .)
    KEY             reduce using rule 3 (file_lines -> line .)
    INTEGER         reduce using rule 3 (file_lines -> line .)
    STRING          reduce using rule 3 (file_lines -> line .)
    STRING_LITERAL  reduce using rule 3 (file_lines -> line .)
    $end            reduce using rule 3 (file_lines -> line .)


state 5

    (5) line -> NEWLINE .

    NEWLINE         reduce using rule 5 (line -> NEWLINE .)
    FLOAT           reduce using rule 5 (line -> NEWLINE .)
    APAR            reduce using rule 5 (line -> NEWLINE .)
    APAR2           reduce using rule 5 (line -> NEWLINE .)
    KEY             reduce using rule 5 (line -> NEWLINE .)
    INTEGER         reduce using rule 5 (line -> NEWLINE .)
    STRING          reduce using rule 5 (line -> NEWLINE .)
    STRING_LITERAL  reduce using rule 5 (line -> NEWLINE .)
    $end            reduce using rule 5 (line -> NEWLINE .)


state 6

    (6) line -> elem_newline .

    NEWLINE         reduce using rule 6 (line -> elem_newline .)
    FLOAT           reduce using rule 6 (line -> elem_newline .)
    APAR            reduce using rule 6 (line -> elem_newline .)
    APAR2           reduce using rule 6 (line -> elem_newline .)
    KEY             reduce using rule 6 (line -> elem_newline .)
    INTEGER         reduce using rule 6 (line -> elem_newline .)
    STRING          reduce using rule 6 (line -> elem_newline .)
    STRING_LITERAL  reduce using rule 6 (line -> elem_newline .)
    $end            reduce using rule 6 (line -> elem_newline .)


state 7

    (9) elem_newline -> atrib . NEWLINE

    NEWLINE         shift and go to state 25


state 8

    (10) elem_newline -> table . NEWLINE
    (59) table -> table . NEWLINE COMMENT
    (60) table -> table . NEWLINE atrib

    NEWLINE         shift and go to state 26


state 9

    (11) elem_newline -> array_table . NEWLINE
    (66) array_table -> array_table . NEWLINE COMMENT
    (67) array_table -> array_table . NEWLINE atrib

    NEWLINE         shift and go to state 27


state 10

    (16) atrib -> FLOAT . EQUALS content

    EQUALS          shift and go to state 28


state 11

    (17) atrib -> key . EQUALS content
    (18) atrib -> key . EQUALS content COMMENT
    (19) atrib -> key . DOT atrib

    EQUALS          shift and go to state 29
    DOT             shift and go to state 30


state 12

    (61) table -> APAR . tab_cont CPAR
    (62) table -> APAR . tab_cont CPAR COMMENT
    (63) tab_cont -> . FLOAT
    (64) tab_cont -> . tab_cont DOT tab_cont
    (65) tab_cont -> . key
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    FLOAT           shift and go to state 32
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    tab_cont                       shift and go to state 31
    key                            shift and go to state 33

state 13

    (68) array_table -> APAR2 . arr_table_cont CPAR2
    (69) array_table -> APAR2 . arr_table_cont CPAR2 COMMENT
    (70) arr_table_cont -> . arr_table_cont DOT arr_table_cont
    (71) arr_table_cont -> . key
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    arr_table_cont                 shift and go to state 34
    key                            shift and go to state 35

state 14

    (39) key -> KEY .

    EQUALS          reduce using rule 39 (key -> KEY .)
    DOT             reduce using rule 39 (key -> KEY .)
    CPAR            reduce using rule 39 (key -> KEY .)
    CPAR2           reduce using rule 39 (key -> KEY .)


state 15

    (40) key -> INTEGER .

    EQUALS          reduce using rule 40 (key -> INTEGER .)
    DOT             reduce using rule 40 (key -> INTEGER .)
    CPAR            reduce using rule 40 (key -> INTEGER .)
    CPAR2           reduce using rule 40 (key -> INTEGER .)


state 16

    (41) key -> STRING .

    EQUALS          reduce using rule 41 (key -> STRING .)
    DOT             reduce using rule 41 (key -> STRING .)
    CPAR            reduce using rule 41 (key -> STRING .)
    CPAR2           reduce using rule 41 (key -> STRING .)


state 17

    (42) key -> STRING_LITERAL .

    EQUALS          reduce using rule 42 (key -> STRING_LITERAL .)
    DOT             reduce using rule 42 (key -> STRING_LITERAL .)
    CPAR            reduce using rule 42 (key -> STRING_LITERAL .)
    CPAR2           reduce using rule 42 (key -> STRING_LITERAL .)


state 18

    (2) file -> file_lines last_line .

    $end            reduce using rule 2 (file -> file_lines last_line .)


state 19

    (4) file_lines -> file_lines line .

    NEWLINE         reduce using rule 4 (file_lines -> file_lines line .)
    FLOAT           reduce using rule 4 (file_lines -> file_lines line .)
    APAR            reduce using rule 4 (file_lines -> file_lines line .)
    APAR2           reduce using rule 4 (file_lines -> file_lines line .)
    KEY             reduce using rule 4 (file_lines -> file_lines line .)
    INTEGER         reduce using rule 4 (file_lines -> file_lines line .)
    STRING          reduce using rule 4 (file_lines -> file_lines line .)
    STRING_LITERAL  reduce using rule 4 (file_lines -> file_lines line .)
    $end            reduce using rule 4 (file_lines -> file_lines line .)


state 20

    (7) last_line -> elem .

    $end            reduce using rule 7 (last_line -> elem .)


state 21

    (8) last_line -> empty .

    $end            reduce using rule 8 (last_line -> empty .)


state 22

    (13) elem -> atrib .
    (9) elem_newline -> atrib . NEWLINE

    $end            reduce using rule 13 (elem -> atrib .)
    NEWLINE         shift and go to state 25


state 23

    (14) elem -> table .
    (10) elem_newline -> table . NEWLINE
    (59) table -> table . NEWLINE COMMENT
    (60) table -> table . NEWLINE atrib

    $end            reduce using rule 14 (elem -> table .)
    NEWLINE         shift and go to state 26


state 24

    (15) elem -> array_table .
    (11) elem_newline -> array_table . NEWLINE
    (66) array_table -> array_table . NEWLINE COMMENT
    (67) array_table -> array_table . NEWLINE atrib

    $end            reduce using rule 15 (elem -> array_table .)
    NEWLINE         shift and go to state 27


state 25

    (9) elem_newline -> atrib NEWLINE .

    NEWLINE         reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    FLOAT           reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    APAR            reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    APAR2           reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    KEY             reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    INTEGER         reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    STRING          reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    STRING_LITERAL  reduce using rule 9 (elem_newline -> atrib NEWLINE .)
    $end            reduce using rule 9 (elem_newline -> atrib NEWLINE .)


state 26

    (10) elem_newline -> table NEWLINE .
    (59) table -> table NEWLINE . COMMENT
    (60) table -> table NEWLINE . atrib
    (16) atrib -> . FLOAT EQUALS content
    (17) atrib -> . key EQUALS content
    (18) atrib -> . key EQUALS content COMMENT
    (19) atrib -> . key DOT atrib
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KEY resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
    NEWLINE         reduce using rule 10 (elem_newline -> table NEWLINE .)
    APAR            reduce using rule 10 (elem_newline -> table NEWLINE .)
    APAR2           reduce using rule 10 (elem_newline -> table NEWLINE .)
    $end            reduce using rule 10 (elem_newline -> table NEWLINE .)
    COMMENT         shift and go to state 36
    FLOAT           shift and go to state 10
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

  ! FLOAT           [ reduce using rule 10 (elem_newline -> table NEWLINE .) ]
  ! KEY             [ reduce using rule 10 (elem_newline -> table NEWLINE .) ]
  ! INTEGER         [ reduce using rule 10 (elem_newline -> table NEWLINE .) ]
  ! STRING          [ reduce using rule 10 (elem_newline -> table NEWLINE .) ]
  ! STRING_LITERAL  [ reduce using rule 10 (elem_newline -> table NEWLINE .) ]

    atrib                          shift and go to state 37
    key                            shift and go to state 11

state 27

    (11) elem_newline -> array_table NEWLINE .
    (66) array_table -> array_table NEWLINE . COMMENT
    (67) array_table -> array_table NEWLINE . atrib
    (16) atrib -> . FLOAT EQUALS content
    (17) atrib -> . key EQUALS content
    (18) atrib -> . key EQUALS content COMMENT
    (19) atrib -> . key DOT atrib
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for KEY resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
    NEWLINE         reduce using rule 11 (elem_newline -> array_table NEWLINE .)
    APAR            reduce using rule 11 (elem_newline -> array_table NEWLINE .)
    APAR2           reduce using rule 11 (elem_newline -> array_table NEWLINE .)
    $end            reduce using rule 11 (elem_newline -> array_table NEWLINE .)
    COMMENT         shift and go to state 38
    FLOAT           shift and go to state 10
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

  ! FLOAT           [ reduce using rule 11 (elem_newline -> array_table NEWLINE .) ]
  ! KEY             [ reduce using rule 11 (elem_newline -> array_table NEWLINE .) ]
  ! INTEGER         [ reduce using rule 11 (elem_newline -> array_table NEWLINE .) ]
  ! STRING          [ reduce using rule 11 (elem_newline -> array_table NEWLINE .) ]
  ! STRING_LITERAL  [ reduce using rule 11 (elem_newline -> array_table NEWLINE .) ]

    atrib                          shift and go to state 39
    key                            shift and go to state 11

state 28

    (16) atrib -> FLOAT EQUALS . content
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    content                        shift and go to state 41
    value                          shift and go to state 42

state 29

    (17) atrib -> key EQUALS . content
    (18) atrib -> key EQUALS . content COMMENT
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    content                        shift and go to state 60
    value                          shift and go to state 42

state 30

    (19) atrib -> key DOT . atrib
    (16) atrib -> . FLOAT EQUALS content
    (17) atrib -> . key EQUALS content
    (18) atrib -> . key EQUALS content COMMENT
    (19) atrib -> . key DOT atrib
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    FLOAT           shift and go to state 10
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    key                            shift and go to state 11
    atrib                          shift and go to state 61

state 31

    (61) table -> APAR tab_cont . CPAR
    (62) table -> APAR tab_cont . CPAR COMMENT
    (64) tab_cont -> tab_cont . DOT tab_cont

    CPAR            shift and go to state 62
    DOT             shift and go to state 63


state 32

    (63) tab_cont -> FLOAT .

    CPAR            reduce using rule 63 (tab_cont -> FLOAT .)
    DOT             reduce using rule 63 (tab_cont -> FLOAT .)


state 33

    (65) tab_cont -> key .

    CPAR            reduce using rule 65 (tab_cont -> key .)
    DOT             reduce using rule 65 (tab_cont -> key .)


state 34

    (68) array_table -> APAR2 arr_table_cont . CPAR2
    (69) array_table -> APAR2 arr_table_cont . CPAR2 COMMENT
    (70) arr_table_cont -> arr_table_cont . DOT arr_table_cont

    CPAR2           shift and go to state 64
    DOT             shift and go to state 65


state 35

    (71) arr_table_cont -> key .

    CPAR2           reduce using rule 71 (arr_table_cont -> key .)
    DOT             reduce using rule 71 (arr_table_cont -> key .)


state 36

    (59) table -> table NEWLINE COMMENT .

    NEWLINE         reduce using rule 59 (table -> table NEWLINE COMMENT .)
    $end            reduce using rule 59 (table -> table NEWLINE COMMENT .)


state 37

    (60) table -> table NEWLINE atrib .

    NEWLINE         reduce using rule 60 (table -> table NEWLINE atrib .)
    $end            reduce using rule 60 (table -> table NEWLINE atrib .)


state 38

    (66) array_table -> array_table NEWLINE COMMENT .

    NEWLINE         reduce using rule 66 (array_table -> array_table NEWLINE COMMENT .)
    $end            reduce using rule 66 (array_table -> array_table NEWLINE COMMENT .)


state 39

    (67) array_table -> array_table NEWLINE atrib .

    NEWLINE         reduce using rule 67 (array_table -> array_table NEWLINE atrib .)
    $end            reduce using rule 67 (array_table -> array_table NEWLINE atrib .)


state 40

    (47) value -> FLOAT .

    NEWLINE         reduce using rule 47 (value -> FLOAT .)
    $end            reduce using rule 47 (value -> FLOAT .)
    COMMENT         reduce using rule 47 (value -> FLOAT .)
    CPAR            reduce using rule 47 (value -> FLOAT .)
    COMMA           reduce using rule 47 (value -> FLOAT .)
    CCHAV           reduce using rule 47 (value -> FLOAT .)


state 41

    (16) atrib -> FLOAT EQUALS content .

    NEWLINE         reduce using rule 16 (atrib -> FLOAT EQUALS content .)
    $end            reduce using rule 16 (atrib -> FLOAT EQUALS content .)


state 42

    (20) content -> value .

    NEWLINE         reduce using rule 20 (content -> value .)
    $end            reduce using rule 20 (content -> value .)
    COMMENT         reduce using rule 20 (content -> value .)
    CPAR            reduce using rule 20 (content -> value .)
    COMMA           reduce using rule 20 (content -> value .)
    CCHAV           reduce using rule 20 (content -> value .)


state 43

    (21) content -> APAR . arr_cont
    (22) content -> APAR . NEWLINE arr_cont
    (24) arr_cont -> . CPAR
    (25) arr_cont -> . a_cont CPAR
    (26) arr_cont -> . a_cont COMMA CPAR
    (27) arr_cont -> . a_cont NEWLINE CPAR
    (28) arr_cont -> . a_cont COMMA NEWLINE CPAR
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    NEWLINE         shift and go to state 67
    CPAR            shift and go to state 68
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    arr_cont                       shift and go to state 66
    a_cont                         shift and go to state 69
    content                        shift and go to state 71
    value                          shift and go to state 42

state 44

    (23) content -> ACHAV . table_cont
    (35) table_cont -> . CCHAV
    (36) table_cont -> . t_cont CCHAV
    (37) t_cont -> . key EQUALS content
    (38) t_cont -> . t_cont COMMA key EQUALS content
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    CCHAV           shift and go to state 73
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    table_cont                     shift and go to state 72
    t_cont                         shift and go to state 74
    key                            shift and go to state 75

state 45

    (43) value -> STRING .

    NEWLINE         reduce using rule 43 (value -> STRING .)
    $end            reduce using rule 43 (value -> STRING .)
    COMMENT         reduce using rule 43 (value -> STRING .)
    CPAR            reduce using rule 43 (value -> STRING .)
    COMMA           reduce using rule 43 (value -> STRING .)
    CCHAV           reduce using rule 43 (value -> STRING .)


state 46

    (44) value -> BOOL .

    NEWLINE         reduce using rule 44 (value -> BOOL .)
    $end            reduce using rule 44 (value -> BOOL .)
    COMMENT         reduce using rule 44 (value -> BOOL .)
    CPAR            reduce using rule 44 (value -> BOOL .)
    COMMA           reduce using rule 44 (value -> BOOL .)
    CCHAV           reduce using rule 44 (value -> BOOL .)


state 47

    (45) value -> NULL .

    NEWLINE         reduce using rule 45 (value -> NULL .)
    $end            reduce using rule 45 (value -> NULL .)
    COMMENT         reduce using rule 45 (value -> NULL .)
    CPAR            reduce using rule 45 (value -> NULL .)
    COMMA           reduce using rule 45 (value -> NULL .)
    CCHAV           reduce using rule 45 (value -> NULL .)


state 48

    (46) value -> INTEGER .

    NEWLINE         reduce using rule 46 (value -> INTEGER .)
    $end            reduce using rule 46 (value -> INTEGER .)
    COMMENT         reduce using rule 46 (value -> INTEGER .)
    CPAR            reduce using rule 46 (value -> INTEGER .)
    COMMA           reduce using rule 46 (value -> INTEGER .)
    CCHAV           reduce using rule 46 (value -> INTEGER .)


state 49

    (48) value -> BINARY .

    NEWLINE         reduce using rule 48 (value -> BINARY .)
    $end            reduce using rule 48 (value -> BINARY .)
    COMMENT         reduce using rule 48 (value -> BINARY .)
    CPAR            reduce using rule 48 (value -> BINARY .)
    COMMA           reduce using rule 48 (value -> BINARY .)
    CCHAV           reduce using rule 48 (value -> BINARY .)


state 50

    (49) value -> OCTAL .

    NEWLINE         reduce using rule 49 (value -> OCTAL .)
    $end            reduce using rule 49 (value -> OCTAL .)
    COMMENT         reduce using rule 49 (value -> OCTAL .)
    CPAR            reduce using rule 49 (value -> OCTAL .)
    COMMA           reduce using rule 49 (value -> OCTAL .)
    CCHAV           reduce using rule 49 (value -> OCTAL .)


state 51

    (50) value -> HEXA .

    NEWLINE         reduce using rule 50 (value -> HEXA .)
    $end            reduce using rule 50 (value -> HEXA .)
    COMMENT         reduce using rule 50 (value -> HEXA .)
    CPAR            reduce using rule 50 (value -> HEXA .)
    COMMA           reduce using rule 50 (value -> HEXA .)
    CCHAV           reduce using rule 50 (value -> HEXA .)


state 52

    (51) value -> NAN .

    NEWLINE         reduce using rule 51 (value -> NAN .)
    $end            reduce using rule 51 (value -> NAN .)
    COMMENT         reduce using rule 51 (value -> NAN .)
    CPAR            reduce using rule 51 (value -> NAN .)
    COMMA           reduce using rule 51 (value -> NAN .)
    CCHAV           reduce using rule 51 (value -> NAN .)


state 53

    (52) value -> INFINITY .

    NEWLINE         reduce using rule 52 (value -> INFINITY .)
    $end            reduce using rule 52 (value -> INFINITY .)
    COMMENT         reduce using rule 52 (value -> INFINITY .)
    CPAR            reduce using rule 52 (value -> INFINITY .)
    COMMA           reduce using rule 52 (value -> INFINITY .)
    CCHAV           reduce using rule 52 (value -> INFINITY .)


state 54

    (53) value -> DATE .

    NEWLINE         reduce using rule 53 (value -> DATE .)
    $end            reduce using rule 53 (value -> DATE .)
    COMMENT         reduce using rule 53 (value -> DATE .)
    CPAR            reduce using rule 53 (value -> DATE .)
    COMMA           reduce using rule 53 (value -> DATE .)
    CCHAV           reduce using rule 53 (value -> DATE .)


state 55

    (54) value -> TIME .

    NEWLINE         reduce using rule 54 (value -> TIME .)
    $end            reduce using rule 54 (value -> TIME .)
    COMMENT         reduce using rule 54 (value -> TIME .)
    CPAR            reduce using rule 54 (value -> TIME .)
    COMMA           reduce using rule 54 (value -> TIME .)
    CCHAV           reduce using rule 54 (value -> TIME .)


state 56

    (55) value -> DATETIME .

    NEWLINE         reduce using rule 55 (value -> DATETIME .)
    $end            reduce using rule 55 (value -> DATETIME .)
    COMMENT         reduce using rule 55 (value -> DATETIME .)
    CPAR            reduce using rule 55 (value -> DATETIME .)
    COMMA           reduce using rule 55 (value -> DATETIME .)
    CCHAV           reduce using rule 55 (value -> DATETIME .)


state 57

    (56) value -> MULTILINE_STRING .

    NEWLINE         reduce using rule 56 (value -> MULTILINE_STRING .)
    $end            reduce using rule 56 (value -> MULTILINE_STRING .)
    COMMENT         reduce using rule 56 (value -> MULTILINE_STRING .)
    CPAR            reduce using rule 56 (value -> MULTILINE_STRING .)
    COMMA           reduce using rule 56 (value -> MULTILINE_STRING .)
    CCHAV           reduce using rule 56 (value -> MULTILINE_STRING .)


state 58

    (57) value -> STRING_LITERAL .

    NEWLINE         reduce using rule 57 (value -> STRING_LITERAL .)
    $end            reduce using rule 57 (value -> STRING_LITERAL .)
    COMMENT         reduce using rule 57 (value -> STRING_LITERAL .)
    CPAR            reduce using rule 57 (value -> STRING_LITERAL .)
    COMMA           reduce using rule 57 (value -> STRING_LITERAL .)
    CCHAV           reduce using rule 57 (value -> STRING_LITERAL .)


state 59

    (58) value -> MULTILINE_STRING_LITERAL .

    NEWLINE         reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)
    $end            reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)
    COMMENT         reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)
    CPAR            reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)
    COMMA           reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)
    CCHAV           reduce using rule 58 (value -> MULTILINE_STRING_LITERAL .)


state 60

    (17) atrib -> key EQUALS content .
    (18) atrib -> key EQUALS content . COMMENT

    NEWLINE         reduce using rule 17 (atrib -> key EQUALS content .)
    $end            reduce using rule 17 (atrib -> key EQUALS content .)
    COMMENT         shift and go to state 76


state 61

    (19) atrib -> key DOT atrib .

    NEWLINE         reduce using rule 19 (atrib -> key DOT atrib .)
    $end            reduce using rule 19 (atrib -> key DOT atrib .)


state 62

    (61) table -> APAR tab_cont CPAR .
    (62) table -> APAR tab_cont CPAR . COMMENT

    NEWLINE         reduce using rule 61 (table -> APAR tab_cont CPAR .)
    $end            reduce using rule 61 (table -> APAR tab_cont CPAR .)
    COMMENT         shift and go to state 77


state 63

    (64) tab_cont -> tab_cont DOT . tab_cont
    (63) tab_cont -> . FLOAT
    (64) tab_cont -> . tab_cont DOT tab_cont
    (65) tab_cont -> . key
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    FLOAT           shift and go to state 32
    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    tab_cont                       shift and go to state 78
    key                            shift and go to state 33

state 64

    (68) array_table -> APAR2 arr_table_cont CPAR2 .
    (69) array_table -> APAR2 arr_table_cont CPAR2 . COMMENT

    NEWLINE         reduce using rule 68 (array_table -> APAR2 arr_table_cont CPAR2 .)
    $end            reduce using rule 68 (array_table -> APAR2 arr_table_cont CPAR2 .)
    COMMENT         shift and go to state 79


state 65

    (70) arr_table_cont -> arr_table_cont DOT . arr_table_cont
    (70) arr_table_cont -> . arr_table_cont DOT arr_table_cont
    (71) arr_table_cont -> . key
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    arr_table_cont                 shift and go to state 80
    key                            shift and go to state 35

state 66

    (21) content -> APAR arr_cont .

    NEWLINE         reduce using rule 21 (content -> APAR arr_cont .)
    $end            reduce using rule 21 (content -> APAR arr_cont .)
    COMMENT         reduce using rule 21 (content -> APAR arr_cont .)
    CPAR            reduce using rule 21 (content -> APAR arr_cont .)
    COMMA           reduce using rule 21 (content -> APAR arr_cont .)
    CCHAV           reduce using rule 21 (content -> APAR arr_cont .)


state 67

    (22) content -> APAR NEWLINE . arr_cont
    (24) arr_cont -> . CPAR
    (25) arr_cont -> . a_cont CPAR
    (26) arr_cont -> . a_cont COMMA CPAR
    (27) arr_cont -> . a_cont NEWLINE CPAR
    (28) arr_cont -> . a_cont COMMA NEWLINE CPAR
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    CPAR            shift and go to state 68
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    arr_cont                       shift and go to state 81
    a_cont                         shift and go to state 69
    content                        shift and go to state 71
    value                          shift and go to state 42

state 68

    (24) arr_cont -> CPAR .

    NEWLINE         reduce using rule 24 (arr_cont -> CPAR .)
    $end            reduce using rule 24 (arr_cont -> CPAR .)
    COMMENT         reduce using rule 24 (arr_cont -> CPAR .)
    CPAR            reduce using rule 24 (arr_cont -> CPAR .)
    COMMA           reduce using rule 24 (arr_cont -> CPAR .)
    CCHAV           reduce using rule 24 (arr_cont -> CPAR .)


state 69

    (25) arr_cont -> a_cont . CPAR
    (26) arr_cont -> a_cont . COMMA CPAR
    (27) arr_cont -> a_cont . NEWLINE CPAR
    (28) arr_cont -> a_cont . COMMA NEWLINE CPAR
    (31) a_cont -> a_cont . COMMA NEWLINE
    (33) a_cont -> a_cont . COMMA a_cont
    (34) a_cont -> a_cont . COMMA NEWLINE a_cont

    CPAR            shift and go to state 82
    COMMA           shift and go to state 83
    NEWLINE         shift and go to state 84


state 70

    (29) a_cont -> COMMENT . NEWLINE a_cont
    (30) a_cont -> COMMENT . NEWLINE

    NEWLINE         shift and go to state 85


state 71

    (32) a_cont -> content .

    CPAR            reduce using rule 32 (a_cont -> content .)
    COMMA           reduce using rule 32 (a_cont -> content .)
    NEWLINE         reduce using rule 32 (a_cont -> content .)


state 72

    (23) content -> ACHAV table_cont .

    NEWLINE         reduce using rule 23 (content -> ACHAV table_cont .)
    $end            reduce using rule 23 (content -> ACHAV table_cont .)
    COMMENT         reduce using rule 23 (content -> ACHAV table_cont .)
    CPAR            reduce using rule 23 (content -> ACHAV table_cont .)
    COMMA           reduce using rule 23 (content -> ACHAV table_cont .)
    CCHAV           reduce using rule 23 (content -> ACHAV table_cont .)


state 73

    (35) table_cont -> CCHAV .

    NEWLINE         reduce using rule 35 (table_cont -> CCHAV .)
    $end            reduce using rule 35 (table_cont -> CCHAV .)
    COMMENT         reduce using rule 35 (table_cont -> CCHAV .)
    CPAR            reduce using rule 35 (table_cont -> CCHAV .)
    COMMA           reduce using rule 35 (table_cont -> CCHAV .)
    CCHAV           reduce using rule 35 (table_cont -> CCHAV .)


state 74

    (36) table_cont -> t_cont . CCHAV
    (38) t_cont -> t_cont . COMMA key EQUALS content

    CCHAV           shift and go to state 86
    COMMA           shift and go to state 87


state 75

    (37) t_cont -> key . EQUALS content

    EQUALS          shift and go to state 88


state 76

    (18) atrib -> key EQUALS content COMMENT .

    NEWLINE         reduce using rule 18 (atrib -> key EQUALS content COMMENT .)
    $end            reduce using rule 18 (atrib -> key EQUALS content COMMENT .)


state 77

    (62) table -> APAR tab_cont CPAR COMMENT .

    NEWLINE         reduce using rule 62 (table -> APAR tab_cont CPAR COMMENT .)
    $end            reduce using rule 62 (table -> APAR tab_cont CPAR COMMENT .)


state 78

    (64) tab_cont -> tab_cont DOT tab_cont .
    (64) tab_cont -> tab_cont . DOT tab_cont

  ! shift/reduce conflict for DOT resolved as shift
    CPAR            reduce using rule 64 (tab_cont -> tab_cont DOT tab_cont .)
    DOT             shift and go to state 63

  ! DOT             [ reduce using rule 64 (tab_cont -> tab_cont DOT tab_cont .) ]


state 79

    (69) array_table -> APAR2 arr_table_cont CPAR2 COMMENT .

    NEWLINE         reduce using rule 69 (array_table -> APAR2 arr_table_cont CPAR2 COMMENT .)
    $end            reduce using rule 69 (array_table -> APAR2 arr_table_cont CPAR2 COMMENT .)


state 80

    (70) arr_table_cont -> arr_table_cont DOT arr_table_cont .
    (70) arr_table_cont -> arr_table_cont . DOT arr_table_cont

  ! shift/reduce conflict for DOT resolved as shift
    CPAR2           reduce using rule 70 (arr_table_cont -> arr_table_cont DOT arr_table_cont .)
    DOT             shift and go to state 65

  ! DOT             [ reduce using rule 70 (arr_table_cont -> arr_table_cont DOT arr_table_cont .) ]


state 81

    (22) content -> APAR NEWLINE arr_cont .

    NEWLINE         reduce using rule 22 (content -> APAR NEWLINE arr_cont .)
    $end            reduce using rule 22 (content -> APAR NEWLINE arr_cont .)
    COMMENT         reduce using rule 22 (content -> APAR NEWLINE arr_cont .)
    CPAR            reduce using rule 22 (content -> APAR NEWLINE arr_cont .)
    COMMA           reduce using rule 22 (content -> APAR NEWLINE arr_cont .)
    CCHAV           reduce using rule 22 (content -> APAR NEWLINE arr_cont .)


state 82

    (25) arr_cont -> a_cont CPAR .

    NEWLINE         reduce using rule 25 (arr_cont -> a_cont CPAR .)
    $end            reduce using rule 25 (arr_cont -> a_cont CPAR .)
    COMMENT         reduce using rule 25 (arr_cont -> a_cont CPAR .)
    CPAR            reduce using rule 25 (arr_cont -> a_cont CPAR .)
    COMMA           reduce using rule 25 (arr_cont -> a_cont CPAR .)
    CCHAV           reduce using rule 25 (arr_cont -> a_cont CPAR .)


state 83

    (26) arr_cont -> a_cont COMMA . CPAR
    (28) arr_cont -> a_cont COMMA . NEWLINE CPAR
    (31) a_cont -> a_cont COMMA . NEWLINE
    (33) a_cont -> a_cont COMMA . a_cont
    (34) a_cont -> a_cont COMMA . NEWLINE a_cont
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    CPAR            shift and go to state 90
    NEWLINE         shift and go to state 91
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    a_cont                         shift and go to state 89
    content                        shift and go to state 71
    value                          shift and go to state 42

state 84

    (27) arr_cont -> a_cont NEWLINE . CPAR

    CPAR            shift and go to state 92


state 85

    (29) a_cont -> COMMENT NEWLINE . a_cont
    (30) a_cont -> COMMENT NEWLINE .
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    CPAR            reduce using rule 30 (a_cont -> COMMENT NEWLINE .)
    COMMA           reduce using rule 30 (a_cont -> COMMENT NEWLINE .)
    NEWLINE         reduce using rule 30 (a_cont -> COMMENT NEWLINE .)
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    a_cont                         shift and go to state 93
    content                        shift and go to state 71
    value                          shift and go to state 42

state 86

    (36) table_cont -> t_cont CCHAV .

    NEWLINE         reduce using rule 36 (table_cont -> t_cont CCHAV .)
    $end            reduce using rule 36 (table_cont -> t_cont CCHAV .)
    COMMENT         reduce using rule 36 (table_cont -> t_cont CCHAV .)
    CPAR            reduce using rule 36 (table_cont -> t_cont CCHAV .)
    COMMA           reduce using rule 36 (table_cont -> t_cont CCHAV .)
    CCHAV           reduce using rule 36 (table_cont -> t_cont CCHAV .)


state 87

    (38) t_cont -> t_cont COMMA . key EQUALS content
    (39) key -> . KEY
    (40) key -> . INTEGER
    (41) key -> . STRING
    (42) key -> . STRING_LITERAL

    KEY             shift and go to state 14
    INTEGER         shift and go to state 15
    STRING          shift and go to state 16
    STRING_LITERAL  shift and go to state 17

    key                            shift and go to state 94

state 88

    (37) t_cont -> key EQUALS . content
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    content                        shift and go to state 95
    value                          shift and go to state 42

state 89

    (33) a_cont -> a_cont COMMA a_cont .
    (31) a_cont -> a_cont . COMMA NEWLINE
    (33) a_cont -> a_cont . COMMA a_cont
    (34) a_cont -> a_cont . COMMA NEWLINE a_cont

  ! shift/reduce conflict for COMMA resolved as shift
    CPAR            reduce using rule 33 (a_cont -> a_cont COMMA a_cont .)
    NEWLINE         reduce using rule 33 (a_cont -> a_cont COMMA a_cont .)
    COMMA           shift and go to state 96

  ! COMMA           [ reduce using rule 33 (a_cont -> a_cont COMMA a_cont .) ]


state 90

    (26) arr_cont -> a_cont COMMA CPAR .

    NEWLINE         reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)
    $end            reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)
    COMMENT         reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)
    CPAR            reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)
    COMMA           reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)
    CCHAV           reduce using rule 26 (arr_cont -> a_cont COMMA CPAR .)


state 91

    (28) arr_cont -> a_cont COMMA NEWLINE . CPAR
    (31) a_cont -> a_cont COMMA NEWLINE .
    (34) a_cont -> a_cont COMMA NEWLINE . a_cont
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

  ! shift/reduce conflict for CPAR resolved as shift
    CPAR            shift and go to state 98
    COMMA           reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .)
    NEWLINE         reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .)
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

  ! CPAR            [ reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .) ]

    a_cont                         shift and go to state 97
    content                        shift and go to state 71
    value                          shift and go to state 42

state 92

    (27) arr_cont -> a_cont NEWLINE CPAR .

    NEWLINE         reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)
    $end            reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)
    COMMENT         reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)
    CPAR            reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)
    COMMA           reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)
    CCHAV           reduce using rule 27 (arr_cont -> a_cont NEWLINE CPAR .)


state 93

    (29) a_cont -> COMMENT NEWLINE a_cont .
    (31) a_cont -> a_cont . COMMA NEWLINE
    (33) a_cont -> a_cont . COMMA a_cont
    (34) a_cont -> a_cont . COMMA NEWLINE a_cont

  ! shift/reduce conflict for COMMA resolved as shift
    CPAR            reduce using rule 29 (a_cont -> COMMENT NEWLINE a_cont .)
    NEWLINE         reduce using rule 29 (a_cont -> COMMENT NEWLINE a_cont .)
    COMMA           shift and go to state 96

  ! COMMA           [ reduce using rule 29 (a_cont -> COMMENT NEWLINE a_cont .) ]


state 94

    (38) t_cont -> t_cont COMMA key . EQUALS content

    EQUALS          shift and go to state 99


state 95

    (37) t_cont -> key EQUALS content .

    CCHAV           reduce using rule 37 (t_cont -> key EQUALS content .)
    COMMA           reduce using rule 37 (t_cont -> key EQUALS content .)


state 96

    (31) a_cont -> a_cont COMMA . NEWLINE
    (33) a_cont -> a_cont COMMA . a_cont
    (34) a_cont -> a_cont COMMA . NEWLINE a_cont
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    NEWLINE         shift and go to state 100
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    a_cont                         shift and go to state 89
    content                        shift and go to state 71
    value                          shift and go to state 42

state 97

    (34) a_cont -> a_cont COMMA NEWLINE a_cont .
    (31) a_cont -> a_cont . COMMA NEWLINE
    (33) a_cont -> a_cont . COMMA a_cont
    (34) a_cont -> a_cont . COMMA NEWLINE a_cont

  ! shift/reduce conflict for COMMA resolved as shift
    CPAR            reduce using rule 34 (a_cont -> a_cont COMMA NEWLINE a_cont .)
    NEWLINE         reduce using rule 34 (a_cont -> a_cont COMMA NEWLINE a_cont .)
    COMMA           shift and go to state 96

  ! COMMA           [ reduce using rule 34 (a_cont -> a_cont COMMA NEWLINE a_cont .) ]


state 98

    (28) arr_cont -> a_cont COMMA NEWLINE CPAR .

    NEWLINE         reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)
    $end            reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)
    COMMENT         reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)
    CPAR            reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)
    COMMA           reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)
    CCHAV           reduce using rule 28 (arr_cont -> a_cont COMMA NEWLINE CPAR .)


state 99

    (38) t_cont -> t_cont COMMA key EQUALS . content
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    content                        shift and go to state 101
    value                          shift and go to state 42

state 100

    (31) a_cont -> a_cont COMMA NEWLINE .
    (34) a_cont -> a_cont COMMA NEWLINE . a_cont
    (29) a_cont -> . COMMENT NEWLINE a_cont
    (30) a_cont -> . COMMENT NEWLINE
    (31) a_cont -> . a_cont COMMA NEWLINE
    (32) a_cont -> . content
    (33) a_cont -> . a_cont COMMA a_cont
    (34) a_cont -> . a_cont COMMA NEWLINE a_cont
    (20) content -> . value
    (21) content -> . APAR arr_cont
    (22) content -> . APAR NEWLINE arr_cont
    (23) content -> . ACHAV table_cont
    (43) value -> . STRING
    (44) value -> . BOOL
    (45) value -> . NULL
    (46) value -> . INTEGER
    (47) value -> . FLOAT
    (48) value -> . BINARY
    (49) value -> . OCTAL
    (50) value -> . HEXA
    (51) value -> . NAN
    (52) value -> . INFINITY
    (53) value -> . DATE
    (54) value -> . TIME
    (55) value -> . DATETIME
    (56) value -> . MULTILINE_STRING
    (57) value -> . STRING_LITERAL
    (58) value -> . MULTILINE_STRING_LITERAL

    COMMA           reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .)
    CPAR            reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .)
    NEWLINE         reduce using rule 31 (a_cont -> a_cont COMMA NEWLINE .)
    COMMENT         shift and go to state 70
    APAR            shift and go to state 43
    ACHAV           shift and go to state 44
    STRING          shift and go to state 45
    BOOL            shift and go to state 46
    NULL            shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 40
    BINARY          shift and go to state 49
    OCTAL           shift and go to state 50
    HEXA            shift and go to state 51
    NAN             shift and go to state 52
    INFINITY        shift and go to state 53
    DATE            shift and go to state 54
    TIME            shift and go to state 55
    DATETIME        shift and go to state 56
    MULTILINE_STRING shift and go to state 57
    STRING_LITERAL  shift and go to state 58
    MULTILINE_STRING_LITERAL shift and go to state 59

    a_cont                         shift and go to state 97
    content                        shift and go to state 71
    value                          shift and go to state 42

state 101

    (38) t_cont -> t_cont COMMA key EQUALS content .

    CCHAV           reduce using rule 38 (t_cont -> t_cont COMMA key EQUALS content .)
    COMMA           reduce using rule 38 (t_cont -> t_cont COMMA key EQUALS content .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FLOAT in state 26 resolved as shift
WARNING: shift/reduce conflict for KEY in state 26 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 26 resolved as shift
WARNING: shift/reduce conflict for STRING in state 26 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 26 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 27 resolved as shift
WARNING: shift/reduce conflict for KEY in state 27 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 27 resolved as shift
WARNING: shift/reduce conflict for DOT in state 78 resolved as shift
WARNING: shift/reduce conflict for DOT in state 80 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 89 resolved as shift
WARNING: shift/reduce conflict for CPAR in state 91 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 93 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 97 resolved as shift
